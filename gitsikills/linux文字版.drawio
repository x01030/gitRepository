<mxfile host="app.diagrams.net" modified="2023-03-23T01:58:53.499Z" agent="5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36" etag="vRqH1EhZ2efeH9g6cJk6" version="21.0.10" type="github">
  <diagram name="第 1 页" id="fNpLfGn5C1ve46DeuQOR">
    <mxGraphModel dx="1434" dy="-405" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-1" value="&lt;font style=&quot;font-size: 14px;&quot;&gt;&lt;b&gt;A.程序执行&lt;/b&gt;：【2.1】&lt;br&gt;1.CPU 读取「程序计数器」的值(下一条指令的内存地址[虚拟地址]);&lt;br&gt;2.1. 访问的虚拟地址在MMU中的TLB快表查到，则转换为物理地址，否则，继续2.2；&lt;br&gt;2.2. 访问的虚拟地址在MMU中的TLB快表查不到，&lt;font color=&quot;#ff3333&quot;&gt;产生缺页异常&lt;/font&gt;，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行，按照2.1操作；&lt;br&gt;3. 虚拟地址经过MMU转换为物理地址；CPU 的「控制单元」操作&lt;font color=&quot;#7ea6e0&quot;&gt;「地址总线」&lt;/font&gt;指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「&lt;font color=&quot;#7ea6e0&quot;&gt;数据总线&lt;/font&gt;」将指令数据传给 CPU；&lt;br&gt;4.CPU 收到&lt;font color=&quot;#7ea6e0&quot;&gt;内存传来的数据&lt;/font&gt;后，将这个指令数据存入到「指令寄存器」；&lt;br&gt;5.&quot;程序计数器&quot;自增，指向下一条指令；&lt;font color=&quot;#7ea6e0&quot;&gt;CPU 分析「指令寄存器」&lt;/font&gt;中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给「逻辑运算单元」运算；如果是存储类型的指令，则交由「控制单元」执行；&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;strokeColor=#BD7000;fillColor=#f0a30a;align=left;verticalAlign=top;fontColor=#000000;" vertex="1" parent="1">
          <mxGeometry x="420" y="1930" width="555" height="230" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-2" value="&lt;font style=&quot;font-size: 14px;&quot;&gt;【CPU读写数据以 CPU Cache Line 大小为为单位，CPU Cache Line 是 CPU 从内存读取数据到 Cache 的单位】【2.4】&lt;b&gt;&lt;br&gt;B1.cpu访问内存的数据(读）&lt;/b&gt;：&lt;br&gt;1.寄存器有，则获取，否则往后；&lt;br&gt;2.L1,L2,L3有，则获取，否则从往后;&lt;br&gt;3.内存有，则数据缓存到cache，最后CPU从cache读取&lt;br&gt;&lt;br&gt;&lt;b style=&quot;border-color: var(--border-color);&quot;&gt;B2.cpu写入数据(写）&lt;/b&gt;：&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;a类：写直达。无论数据在不在 Cache 里面，每次写操作都会写回到&lt;font style=&quot;border-color: var(--border-color);&quot; color=&quot;#ff3333&quot;&gt;内存&lt;/font&gt;。&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;b类：写回。只有在&lt;font style=&quot;border-color: var(--border-color);&quot; color=&quot;#ff3333&quot;&gt;缓存不命中，同时数据对应的 Cache 中的 Cache Block 为脏标记的情况下&lt;/font&gt;，才会将数据写到内存中；在&lt;font style=&quot;border-color: var(--border-color);&quot; color=&quot;#ff3333&quot;&gt;缓存命中(数据在cache中)&lt;/font&gt;的情况下，则在写入后 Cache 后，只需把该数据对应的 Cache Block 标记为脏即可，而不用写到内存里。&lt;br style=&quot;border-color: var(--border-color);&quot;&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;strokeColor=#82b366;fillColor=#d5e8d4;align=left;verticalAlign=top;gradientColor=#97d077;" vertex="1" parent="1">
          <mxGeometry x="414" y="2200" width="520" height="230" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-3" value="&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;拷问：&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;ul style=&quot;user-select: auto;&quot;&gt;&lt;li style=&quot;user-select: auto;&quot;&gt;&lt;font style=&quot;user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;第2章_硬件结构&lt;/b&gt;&lt;/font&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/b&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;1. 有了内存，为什么还需要 CPU Cache？&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;2. CPU 是怎么读写数据的？&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;3. 如何让 CPU 能读取数据更快一些？&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;4. CPU 伪共享是如何发生的？又该如何避免？&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;5. CPU 是如何调度任务的？如果你的任务对响应要求很高，你希望它总是能被先调度，这该怎么办？&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;ul style=&quot;user-select: auto;&quot;&gt;&lt;li style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;第4章_内存管理&lt;/b&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;1. 为什么要有虚拟内存？&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;2.1. malloc 是如何分配内存的？为什么不仅用brk或仅用mmap系统调用分配内存？&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;2.2. malloc 分配的是物理内存吗？&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;2.3. malloc(1) 会分配多大的内存？&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;2.4. free 释放内存，会归还给操作系统吗？&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;2.5. free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;3. 内存满了，会发生什么？&lt;/span&gt;&lt;/div&gt;&lt;/font&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;4.&amp;nbsp;&lt;/span&gt;在 4GB 物理内存的机器上，申请 8G 内存会怎么样？&lt;br&gt;5.1. 操作系统在读磁盘的时候会额外多读一些到内存中，但是最后这些数据也没有用到，有什么改善的方法吗？&lt;br&gt;5.2. 批量读数据的时候，可能会把热点数据挤出去，这个又有什么改善方法呢？" style="rounded=0;whiteSpace=wrap;html=1;strokeColor=#36393d;fillColor=#cce5ff;align=left;verticalAlign=top;" vertex="1" parent="1">
          <mxGeometry x="11" y="2487" width="610" height="490" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-4" value="&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;解答：&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;ul style=&quot;user-select: auto;&quot;&gt;&lt;li style=&quot;user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;第2章_硬件结构&lt;/b&gt;&lt;/font&gt;&amp;nbsp;&lt;/li&gt;&lt;/ul&gt;&lt;/b&gt;&lt;/font&gt;1. Cache 作为 CPU 与内存之间的缓存层，以减少对内存的访问频率。&lt;br style=&quot;user-select: auto;&quot;&gt;2. 见上文字&lt;br style=&quot;user-select: auto;&quot;&gt;3.&amp;nbsp;如果我们操作的数据是数组，那么访问数组元素的时候，&lt;font style=&quot;font-size: 14px; user-select: auto;&quot; color=&quot;#ff3333&quot;&gt;按内存分布的地址顺序进行访问&lt;/font&gt;，这样能充分利用到 Cache，程序的性能得到提升。但如果操作的数据不是数组，而是普通的变量，并在多核 CPU 的情况下，我们还需要避免 Cache Line 伪共享的问题。&lt;br style=&quot;user-select: auto;&quot;&gt;4.&amp;nbsp;多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为&lt;font style=&quot;font-size: 14px; user-select: auto;&quot; color=&quot;#ff3333&quot;&gt;伪共享&lt;/font&gt;。&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;/font&gt;&lt;ul style=&quot;border-color: var(--border-color); font-size: 14px; user-select: auto;&quot;&gt;&lt;li style=&quot;border-color: var(--border-color); user-select: auto;&quot;&gt;&lt;b style=&quot;border-color: var(--border-color); user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;第4章_内存管理&lt;/font&gt;&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;/p&gt;&lt;div style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;1.&lt;/b&gt;&amp;nbsp;第一，&lt;font style=&quot;font-size: 14px; user-select: auto;&quot; color=&quot;#ff3333&quot;&gt;虚拟内存可以使得进程对运行内存超过物理内存大小&lt;/font&gt;。&lt;/font&gt;&lt;/div&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。&lt;/span&gt;&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;第二，&lt;/span&gt;&lt;font style=&quot;background-color: initial; font-size: 14px; user-select: auto;&quot; color=&quot;#ff3333&quot;&gt;解决了多进程之间地址冲突的问题&lt;/font&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;。&lt;/span&gt;&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot; color=&quot;#ff3333&quot;&gt;由于每个进程都有自己的页表&lt;/font&gt;，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。&lt;/span&gt;&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;第三，&lt;/span&gt;&lt;font style=&quot;background-color: initial; font-size: 14px; user-select: auto;&quot; color=&quot;#ff3333&quot;&gt;在内存访问方面，操作系统提供了更好的安全性&lt;/font&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;。&lt;/span&gt;&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;/font&gt;&lt;div style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;2.1&amp;amp;&amp;amp;2.4&lt;/b&gt;.&amp;nbsp;&amp;nbsp;malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存；&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 方式一：用户分配的内存&amp;lt; 128 KB，通过 brk() 系统调用从堆分配内存【maps有heap表示】；free 释放内存后，堆内&lt;/span&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;存还是存在的，并没有归还给操作系统。&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;font style=&quot;user-select: auto;&quot;&gt;&lt;div style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 方式二：用户分配的内&amp;gt;=128 KB，通过 mmap() 系统调用在文件映射区域分配内存【匿名映射，maps无标识】；free 释放内存后就会归归还给操作系统。&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span style=&quot;background-color: initial; font-size: 14px; user-select: auto;&quot;&gt;仅用方式1，随着系统频繁地 malloc 和 free ，尤其对于小块内存，堆内将产生越来越多不可用的碎片，导致“内存泄露”。而这种“泄露”现象使用 valgrind 是无法检测出来的。&lt;/span&gt;&lt;/div&gt;&lt;/font&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;仅用方式2，mmap 分配的内存每次释放的时候，都会归还给操作系统；频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; background-color: initial; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;2.2&lt;/b&gt;. malloc() 分配的是虚拟内存。&lt;/span&gt;&lt;font style=&quot;font-size: 14px; background-color: initial; user-select: auto;&quot; color=&quot;#ff8000&quot;&gt;如果分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存的，这样就不会占用物理内存了。&lt;/font&gt;&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;2.3&lt;/b&gt;.&amp;nbsp;malloc() 在分配内存的时候，并不是老老实实按用户预期申请的字节数来分配内存空间大小，而是会预分配更大的空间作为内存池。&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;2.5&lt;/b&gt;.&amp;nbsp;&amp;nbsp;执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存。&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;div style=&quot;border-color: var(--border-color); user-select: auto;&quot;&gt;&lt;b style=&quot;border-color: var(--border-color); user-select: auto;&quot;&gt;3&lt;/b&gt;. 见上图。“内存压力大”。&lt;/div&gt;&lt;div style=&quot;border-color: var(--border-color); user-select: auto;&quot;&gt;&lt;b style=&quot;border-color: var(--border-color); user-select: auto;&quot;&gt;4&lt;/b&gt;. 见上图。“4G物理内存的机器，申请8G内存，怎样？&lt;span style=&quot;background-color: initial;&quot;&gt;”&lt;/span&gt;&lt;/div&gt;&lt;/font&gt;&lt;/div&gt;&lt;p style=&quot;user-select: auto;&quot;&gt;&lt;/p&gt;" style="rounded=0;whiteSpace=wrap;html=1;strokeColor=#36393d;fillColor=#cce5ff;align=left;verticalAlign=top;" vertex="1" parent="1">
          <mxGeometry x="639" y="2487" width="770" height="670" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-6" style="edgeStyle=orthogonalEdgeStyle;curved=1;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;fontFamily=Helvetica;fontSize=14;fontColor=#000000;startArrow=none;startFill=0;endArrow=classic;endFill=1;" edge="1" parent="1" source="XP6LI39cL5Eo3HFnyTUD-7" target="XP6LI39cL5Eo3HFnyTUD-8">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-7" value="&lt;font color=&quot;#000000&quot;&gt;(物理)分段&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;strokeColor=#000000;fontFamily=Helvetica;fontSize=14;fontColor=#FF8000;fillColor=#FF3399;" vertex="1" parent="1">
          <mxGeometry x="1140" y="1706" width="90" height="40" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-8" value="&lt;font color=&quot;#000000&quot;&gt;(物理)分页&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;strokeColor=#000000;fontFamily=Helvetica;fontSize=14;fontColor=#FF8000;fillColor=#FF3399;" vertex="1" parent="1">
          <mxGeometry x="1140" y="1836.5" width="90" height="30" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-9" value="" style="shape=curlyBracket;whiteSpace=wrap;html=1;rounded=1;labelPosition=left;verticalLabelPosition=middle;align=right;verticalAlign=middle;strokeColor=#000000;fontFamily=Helvetica;fontSize=14;fontColor=#000000;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="1234" y="1700" width="20" height="50" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-10" value="优点：程序本身不需要关心具体的物理内存地址" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;fontSize=14;fontFamily=Helvetica;fontColor=#000000;" vertex="1" parent="1">
          <mxGeometry x="1254" y="1687" width="320" height="30" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-11" value="缺点：产生外部内存碎片；&lt;br&gt;内存交换的效率低：硬盘的访问速度要比内存慢太多了，&lt;br&gt;每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上，使得整个机器卡顿" style="text;html=1;align=left;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;fontSize=14;fontFamily=Helvetica;fontColor=#000000;" vertex="1" parent="1">
          <mxGeometry x="1264" y="1730" width="560" height="60" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-12" value="" style="shape=curlyBracket;whiteSpace=wrap;html=1;rounded=1;labelPosition=left;verticalLabelPosition=middle;align=right;verticalAlign=middle;strokeColor=#000000;fontFamily=Helvetica;fontSize=14;fontColor=#000000;fillColor=none;" vertex="1" parent="1">
          <mxGeometry x="1240" y="1799.5" width="20" height="117" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-13" value="&lt;font style=&quot;font-size: 14px;&quot;&gt;优点：1. 采取分页，页与页之间是紧密排列的，所以不会有外部碎片；&lt;br style=&quot;border-color: var(--border-color); text-align: center;&quot;&gt;&lt;span style=&quot;text-align: center;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;2. 内存交换效率提高：物理内存空间不够时，操作系统会把其他正在运行的进程中的「最近没被使用」的物理内存页面给释放掉，也就是暂时写在硬盘上，称为&lt;/span&gt;&lt;font color=&quot;#ff3333&quot;&gt;换出&lt;/font&gt;；一旦需要的时候，再加载进来，称为&lt;font color=&quot;#ff3333&quot;&gt;换入&lt;/font&gt;。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间。&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;strokeColor=none;fillColor=none;align=left;verticalAlign=top;" vertex="1" parent="1">
          <mxGeometry x="1270" y="1786.5" width="540" height="100" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-14" value="&lt;font style=&quot;font-size: 14px;&quot;&gt;缺点：简单的一级页表会耗尽物理内存。&lt;br&gt;&lt;span style=&quot;white-space: pre;&quot;&gt; &lt;/span&gt;在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 4MB 的内存来存储页表。因此&lt;code style=&quot;font-family: source-code-pro, Menlo, Monaco, Consolas, &amp;quot;Courier New&amp;quot;, monospace; color: rgb(71, 101, 130); padding: 0.25rem 0.5rem; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px;&quot;&gt;100&lt;/code&gt;&amp;nbsp;个进程的话，就需要&amp;nbsp;&lt;code style=&quot;font-family: source-code-pro, Menlo, Monaco, Consolas, &amp;quot;Courier New&amp;quot;, monospace; color: rgb(71, 101, 130); padding: 0.25rem 0.5rem; margin: 0px; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px;&quot;&gt;400MB&lt;/code&gt;&lt;span style=&quot;color: rgb(44, 62, 80); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Segoe UI&amp;quot;, Roboto, Oxygen, Ubuntu, Cantarell, &amp;quot;Fira Sans&amp;quot;, &amp;quot;Droid Sans&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, sans-serif; background-color: rgb(255, 255, 255);&quot;&gt;&amp;nbsp;的内存来存储页表。&lt;br&gt;&lt;/span&gt;&lt;span style=&quot;white-space: pre;&quot;&gt; &lt;/span&gt;因此，采用多级页表。&lt;span style=&quot;white-space: pre;&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;strokeColor=none;fillColor=none;align=left;verticalAlign=top;" vertex="1" parent="1">
          <mxGeometry x="1270" y="1886.5" width="540" height="110" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-15" value="&lt;font style=&quot;font-size: 14px;&quot;&gt;&lt;b&gt;C.中断&lt;/b&gt;：【2.6】&lt;br&gt;1. 上半部：处理硬件请求(网卡)，硬中断。如：网卡收到网络包后，通过 DMA 方式将接收到的数据写入内存，接着会通过&lt;font color=&quot;#ff3333&quot;&gt;硬件中断&lt;/font&gt;通知内核有新的数据到了，接着会先禁止网卡中断，避免频繁硬中断，而降低内核的工作效率。&lt;br&gt;2. 下半部：由内核触发，软中断。内核就会调用对应的&lt;font color=&quot;#ff3333&quot;&gt;中断处理程&lt;/font&gt;序来处理该事件。如：从内存中找到网络数据，再按照网络协议栈，对网络数据进行逐层解析和处理，最后把数据送给应用程序。&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;strokeColor=#b85450;fillColor=#f8cecc;align=left;verticalAlign=top;gradientColor=#ea6b66;" vertex="1" parent="1">
          <mxGeometry x="1824" y="1440" width="470" height="170" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-16" value="" style="group" vertex="1" connectable="0" parent="1">
          <mxGeometry x="1613" y="2110" width="454.76" height="514" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-17" value="&lt;font color=&quot;#b5739d&quot;&gt;操作系统位数？&lt;/font&gt;" style="rhombus;whiteSpace=wrap;html=1;fontSize=14;" vertex="1" parent="XP6LI39cL5Eo3HFnyTUD-16">
          <mxGeometry x="65" y="76.5" width="120" height="50" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-18" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" edge="1" parent="XP6LI39cL5Eo3HFnyTUD-16" source="XP6LI39cL5Eo3HFnyTUD-19" target="XP6LI39cL5Eo3HFnyTUD-17">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-19" value="4G物理内存的机器，申请8G内存，怎样？" style="rounded=0;whiteSpace=wrap;html=1;fontSize=14;" vertex="1" parent="XP6LI39cL5Eo3HFnyTUD-16">
          <mxGeometry x="10" width="230" height="34" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-20" value="32G无法申请，进程最多申请8G内存" style="whiteSpace=wrap;html=1;fontSize=14;" vertex="1" parent="XP6LI39cL5Eo3HFnyTUD-16">
          <mxGeometry x="280" y="76.5" width="130" height="52.5" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-21" value="32位" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" edge="1" parent="XP6LI39cL5Eo3HFnyTUD-16" source="XP6LI39cL5Eo3HFnyTUD-17" target="XP6LI39cL5Eo3HFnyTUD-20">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-22" value="申请8G内存成功，最大可申请128T" style="whiteSpace=wrap;html=1;fontSize=14;" vertex="1" parent="XP6LI39cL5Eo3HFnyTUD-16">
          <mxGeometry x="62.5" y="174" width="125" height="30" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-23" value="64位" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" edge="1" parent="XP6LI39cL5Eo3HFnyTUD-16" source="XP6LI39cL5Eo3HFnyTUD-17" target="XP6LI39cL5Eo3HFnyTUD-22">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-24" value="注：申请8G内存，指的是malloc虚拟内存" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="XP6LI39cL5Eo3HFnyTUD-16">
          <mxGeometry x="260" y="3.5" width="160" height="30.5" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-25" value="&lt;font color=&quot;#b5739d&quot;&gt;访问虚拟地址的内容？&lt;/font&gt;" style="rhombus;whiteSpace=wrap;html=1;fontSize=14;" vertex="1" parent="XP6LI39cL5Eo3HFnyTUD-16">
          <mxGeometry x="55.62999999999988" y="224" width="138.75" height="50" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-26" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" edge="1" parent="XP6LI39cL5Eo3HFnyTUD-16" source="XP6LI39cL5Eo3HFnyTUD-22" target="XP6LI39cL5Eo3HFnyTUD-25">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-27" value="&lt;font color=&quot;#b5739d&quot;&gt;开启swap机制？&lt;/font&gt;" style="rhombus;whiteSpace=wrap;html=1;fontSize=14;" vertex="1" parent="XP6LI39cL5Eo3HFnyTUD-16">
          <mxGeometry x="57.12000000000012" y="304" width="138.75" height="50" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-28" value="Y" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" edge="1" parent="XP6LI39cL5Eo3HFnyTUD-16" source="XP6LI39cL5Eo3HFnyTUD-25" target="XP6LI39cL5Eo3HFnyTUD-27">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-29" value="触发内存回收，访问8G虚拟内存成功进程正常运行" style="whiteSpace=wrap;html=1;fontSize=14;" vertex="1" parent="XP6LI39cL5Eo3HFnyTUD-16">
          <mxGeometry x="65.00499999999988" y="384" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-30" value="Y" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" edge="1" parent="XP6LI39cL5Eo3HFnyTUD-16" source="XP6LI39cL5Eo3HFnyTUD-27" target="XP6LI39cL5Eo3HFnyTUD-29">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-31" value="结束" style="whiteSpace=wrap;html=1;fontSize=14;rounded=1;" vertex="1" parent="XP6LI39cL5Eo3HFnyTUD-16">
          <mxGeometry x="78.5" y="484" width="93" height="30" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-32" value="N" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;exitX=0;exitY=0.5;exitDx=0;exitDy=0;" edge="1" parent="XP6LI39cL5Eo3HFnyTUD-16" source="XP6LI39cL5Eo3HFnyTUD-25" target="XP6LI39cL5Eo3HFnyTUD-31">
          <mxGeometry x="-0.9032" relative="1" as="geometry">
            <Array as="points">
              <mxPoint y="249" />
              <mxPoint y="499" />
            </Array>
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-33" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" edge="1" parent="XP6LI39cL5Eo3HFnyTUD-16" source="XP6LI39cL5Eo3HFnyTUD-29" target="XP6LI39cL5Eo3HFnyTUD-31">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-34" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=1;entryY=0.5;entryDx=0;entryDy=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;" edge="1" parent="XP6LI39cL5Eo3HFnyTUD-16" source="XP6LI39cL5Eo3HFnyTUD-35" target="XP6LI39cL5Eo3HFnyTUD-31">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-35" value="累计访问4G的虚拟内存成功，之后超过实际的物理内存4G会访问失败" style="whiteSpace=wrap;html=1;fontSize=14;" vertex="1" parent="XP6LI39cL5Eo3HFnyTUD-16">
          <mxGeometry x="260" y="299.6300000000001" width="194.76" height="58.75" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-36" value="N" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" edge="1" parent="XP6LI39cL5Eo3HFnyTUD-16" source="XP6LI39cL5Eo3HFnyTUD-27" target="XP6LI39cL5Eo3HFnyTUD-35">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-37" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;curved=1;strokeColor=#B5739D;dashed=1;" edge="1" parent="XP6LI39cL5Eo3HFnyTUD-16">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="194.3800000000001" y="329" as="sourcePoint" />
            <mxPoint x="373.27" y="-40" as="targetPoint" />
          </mxGeometry>
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
