<mxfile host="app.diagrams.net" modified="2023-03-31T00:55:04.470Z" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36" etag="7l8tnq-FP2CztLgUrOxs" version="21.1.0" type="github">
  <diagram name="第 1 页" id="fNpLfGn5C1ve46DeuQOR">
    <mxGraphModel dx="761" dy="-517" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-1" value="&lt;font style=&quot;font-size: 14px;&quot;&gt;&lt;b&gt;A.程序执行&lt;/b&gt;：【2.1】&lt;br&gt;1.CPU 读取「程序计数器」的值(下一条指令的内存地址[虚拟地址]);&lt;br&gt;2.1. 访问的虚拟地址在MMU中的TLB快表查到，则转换为物理地址，否则，继续2.2；&lt;br&gt;2.2. 访问的虚拟地址在MMU中的TLB快表查不到，&lt;font color=&quot;#ff3333&quot;&gt;产生缺页异常&lt;/font&gt;，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行，按照2.1操作；&lt;br&gt;3. 虚拟地址经过MMU转换为物理地址；CPU 的「控制单元」操作&lt;font color=&quot;#7ea6e0&quot;&gt;「地址总线」&lt;/font&gt;指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「&lt;font color=&quot;#7ea6e0&quot;&gt;数据总线&lt;/font&gt;」将指令数据传给 CPU；&lt;br&gt;4.CPU 收到&lt;font color=&quot;#7ea6e0&quot;&gt;内存传来的数据&lt;/font&gt;后，将这个指令数据存入到「指令寄存器」；&lt;br&gt;5.&quot;程序计数器&quot;自增，指向下一条指令；&lt;font color=&quot;#7ea6e0&quot;&gt;CPU 分析「指令寄存器」&lt;/font&gt;中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给「逻辑运算单元」运算；如果是存储类型的指令，则交由「控制单元」执行；&lt;br&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;strokeColor=#BD7000;fillColor=#f0a30a;align=left;verticalAlign=top;fontColor=#000000;" parent="1" vertex="1">
          <mxGeometry x="420" y="1930" width="555" height="230" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-2" value="&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;【CPU读写数据以 CPU Cache Line 大小为为单位，CPU Cache Line 是 CPU 从内存读取数据到 Cache 的单位】【2.4】&lt;b style=&quot;user-select: auto;&quot;&gt;&lt;br style=&quot;user-select: auto;&quot;&gt;B1.cpu访问内存的数据(读）&lt;/b&gt;：&lt;br style=&quot;user-select: auto;&quot;&gt;1.寄存器有，则获取，否则往后；&lt;br style=&quot;user-select: auto;&quot;&gt;2.L1,L2,L3有，则获取，否则从往后;&lt;br style=&quot;user-select: auto;&quot;&gt;3.内存有，则数据缓存到cache，最后CPU从cache读取，否则往后；&lt;br style=&quot;user-select: auto;&quot;&gt;4.从硬盘读取数据到内存。&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;b style=&quot;border-color: var(--border-color); user-select: auto;&quot;&gt;B2.cpu写入数据(写）&lt;/b&gt;：&lt;br style=&quot;border-color: var(--border-color); user-select: auto;&quot;&gt;a类：写直达。无论数据在不在 Cache 里面，每次写操作都会写回到&lt;font style=&quot;border-color: var(--border-color); user-select: auto;&quot; color=&quot;#ff3333&quot;&gt;内存&lt;/font&gt;。&lt;br style=&quot;border-color: var(--border-color); user-select: auto;&quot;&gt;b类：写回。只有在&lt;font style=&quot;border-color: var(--border-color); user-select: auto;&quot; color=&quot;#ff3333&quot;&gt;缓存不命中，同时数据对应的 Cache 中的 Cache Block 为脏标记的情况下&lt;/font&gt;，才会将数据写到内存中；在&lt;font style=&quot;border-color: var(--border-color); user-select: auto;&quot; color=&quot;#ff3333&quot;&gt;缓存命中(数据在cache中)&lt;/font&gt;的情况下，则在写入后 Cache 后，只需把该数据对应的 Cache Block 标记为脏即可，而不用写到内存里。&lt;br style=&quot;border-color: var(--border-color); user-select: auto;&quot;&gt;&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;strokeColor=#82b366;fillColor=#66FF66;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="420" y="2200" width="540" height="240" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-3" value="&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;拷问：&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;ul style=&quot;user-select: auto;&quot;&gt;&lt;li style=&quot;user-select: auto;&quot;&gt;&lt;font style=&quot;user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;第2章_硬件结构&lt;/b&gt;&lt;/font&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/b&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;1. 有了内存，为什么还需要 CPU Cache？&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;2. CPU 是怎么读写数据的？&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;3. 如何让 CPU 能读取数据更快一些？&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;font color=&quot;#ff33ff&quot; style=&quot;user-select: auto;&quot;&gt;4. CPU 伪共享是如何发生的？又该如何避免？&lt;/font&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;5. CPU 是如何调度任务的？如果你的任务对响应要求很高，你希望它总是能被先调度，这该怎么办？&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;ul style=&quot;user-select: auto;&quot;&gt;&lt;li style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;第4章_内存管理&lt;/b&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;1. 为什么要有虚拟内存？&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;2.1. malloc 是如何分配内存的？为什么不仅用brk或仅用mmap系统调用分配内存？&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;2.2. malloc 分配的是物理内存吗？&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;2.3. malloc(1) 会分配多大的内存？&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;2.4. free 释放内存，会归还给操作系统吗？&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;2.5. free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;3. 内存满了，会发生什么？&lt;/span&gt;&lt;/div&gt;&lt;/font&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;span style=&quot;user-select: auto;&quot;&gt;4.&amp;nbsp;&lt;/span&gt;在 4GB 物理内存的机器上，申请 8G 内存会怎么样？&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;font style=&quot;user-select: auto;&quot; color=&quot;#ff33ff&quot;&gt;5.1. 操作系统在读磁盘的时候会额外多读一些到内存中，但是最后这些数据也没有用到，有什么改善的方法吗？&lt;br style=&quot;user-select: auto;&quot;&gt;5.2. 批量读数据的时候，可能会把热点数据挤出去，这个又有什么改善方法呢&lt;/font&gt;？&lt;/font&gt;" style="rounded=0;whiteSpace=wrap;html=1;strokeColor=#36393d;fillColor=#cce5ff;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="11" y="2487" width="610" height="490" as="geometry" />
        </mxCell>
        <mxCell id="XP6LI39cL5Eo3HFnyTUD-4" value="&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;解答：&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;ul style=&quot;user-select: auto;&quot;&gt;&lt;li style=&quot;user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;第2章_硬件结构&lt;/b&gt;&lt;/font&gt;&amp;nbsp;&lt;/li&gt;&lt;/ul&gt;&lt;/b&gt;&lt;/font&gt;1. Cache 作为 CPU 与内存之间的缓存层，以减少对内存的访问频率。&lt;br style=&quot;user-select: auto;&quot;&gt;2. 见上文字&lt;br style=&quot;user-select: auto;&quot;&gt;3.&amp;nbsp;如果我们操作的数据是数组，那么访问数组元素的时候，&lt;font style=&quot;font-size: 14px; user-select: auto;&quot; color=&quot;#ff3333&quot;&gt;按内存分布的地址顺序进行访问&lt;/font&gt;，这样能充分利用到 Cache，程序的性能得到提升。但如果操作的数据不是数组，而是普通的变量，并在多核 CPU 的情况下，我们还需要避免 Cache Line 伪共享的问题。&lt;br style=&quot;user-select: auto;&quot;&gt;4.&amp;nbsp;多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为&lt;font style=&quot;font-size: 14px; user-select: auto;&quot; color=&quot;#ff3333&quot;&gt;伪共享&lt;/font&gt;。在我们不使用数组，而是使用单独的变量的时候，则会有 Cache 伪共享的问题。&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;/font&gt;&lt;ul style=&quot;border-color: var(--border-color); font-size: 14px; user-select: auto;&quot;&gt;&lt;li style=&quot;border-color: var(--border-color); user-select: auto;&quot;&gt;&lt;b style=&quot;border-color: var(--border-color); user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;第4章_内存管理&lt;/font&gt;&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;/p&gt;&lt;div style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;1.&lt;/b&gt;&amp;nbsp;第一，&lt;font style=&quot;font-size: 14px; user-select: auto;&quot; color=&quot;#ff3333&quot;&gt;虚拟内存可以使得进程对运行内存超过物理内存大小&lt;/font&gt;。&lt;/font&gt;&lt;/div&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。&lt;/span&gt;&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;第二，&lt;/span&gt;&lt;font style=&quot;background-color: initial; font-size: 14px; user-select: auto;&quot; color=&quot;#ff3333&quot;&gt;解决了多进程之间地址冲突的问题&lt;/font&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;。&lt;/span&gt;&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot; color=&quot;#ff3333&quot;&gt;由于每个进程都有自己的页表&lt;/font&gt;，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。&lt;/span&gt;&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;第三，&lt;/span&gt;&lt;font style=&quot;background-color: initial; font-size: 14px; user-select: auto;&quot; color=&quot;#ff3333&quot;&gt;在内存访问方面，操作系统提供了更好的安全性&lt;/font&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;。&lt;/span&gt;&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;/font&gt;&lt;div style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;2.1&amp;amp;&amp;amp;2.4&lt;/b&gt;.&amp;nbsp;&amp;nbsp;malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存；&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 方式一：用户分配的内存&amp;lt; 128 KB，通过 brk() 系统调用从堆分配内存【maps有heap表示】；free 释放内存后，堆内&lt;/span&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;存还是存在的，并没有归还给操作系统。&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;font style=&quot;user-select: auto;&quot;&gt;&lt;div style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 方式二：用户分配的内&amp;gt;=128 KB，通过 mmap() 系统调用在文件映射区域分配内存【匿名映射，maps无标识】；free 释放内存后就会归归还给操作系统。&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span style=&quot;background-color: initial; font-size: 14px; user-select: auto;&quot;&gt;仅用方式1，随着系统频繁地 malloc 和 free ，尤其对于小块内存，堆内将产生越来越多不可用的碎片，导致“内存泄露”。而这种“泄露”现象使用 valgrind 是无法检测出来的。&lt;/span&gt;&lt;/div&gt;&lt;/font&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;仅用方式2，mmap 分配的内存每次释放的时候，都会归还给操作系统；频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;span style=&quot;font-size: 14px; background-color: initial; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;2.2&lt;/b&gt;. malloc() 分配的是虚拟内存。&lt;/span&gt;&lt;font style=&quot;font-size: 14px; background-color: initial; user-select: auto;&quot; color=&quot;#ff8000&quot;&gt;如果分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存的，这样就不会占用物理内存了。&lt;/font&gt;&lt;br style=&quot;user-select: auto;&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;2.3&lt;/b&gt;.&amp;nbsp;malloc() 在分配内存的时候，并不是老老实实按用户预期申请的字节数来分配内存空间大小，而是会预分配更大的空间作为内存池。&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;2.5&lt;/b&gt;.&amp;nbsp;&amp;nbsp;执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存。&lt;/font&gt;&lt;/div&gt;&lt;div style=&quot;user-select: auto;&quot;&gt;&lt;font style=&quot;user-select: auto;&quot;&gt;&lt;div style=&quot;font-size: 14px; border-color: var(--border-color); user-select: auto;&quot;&gt;&lt;b style=&quot;border-color: var(--border-color); user-select: auto;&quot;&gt;3&lt;/b&gt;. 见上图。“内存压力大”。&lt;/div&gt;&lt;div style=&quot;font-size: 14px; border-color: var(--border-color); user-select: auto;&quot;&gt;&lt;b style=&quot;border-color: var(--border-color); user-select: auto;&quot;&gt;4&lt;/b&gt;. 见上图。“4G物理内存的机器，申请8G内存，怎样？&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;”&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-size: 14px; border-color: var(--border-color); user-select: auto;&quot;&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;5.1&lt;/b&gt;. 简称“预读失败”，Linux 操作系统实现两个了 LRU 链表：活跃 LRU 链表（active list）和非活跃 LRU 链表（inactive list）。预读页就只需要加入到 inactive list 区域的头部，当页被真正访问的时候，才将页插入 active list 的头部。如果预读的页一直没有被访问，就会从 inactive list 移除，这样就不会影响 active list 中的热点数据。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-size: 14px; border-color: var(--border-color); user-select: auto;&quot;&gt;&lt;span style=&quot;background-color: initial; user-select: auto;&quot;&gt;&lt;b style=&quot;user-select: auto;&quot;&gt;5.2&lt;/b&gt;. 简称“缓存污染”。当我们在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到「活跃 LRU 链表」里，然后之前缓存在活跃 LRU 链表（或者 young 区域）里的热点数据全部都被淘汰了，如果这些大量的数据在很长一段时间都不会被访问的话，那么整个活跃 LRU 链表（或者 young 区域）就被污染了。&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;border-color: var(--border-color); user-select: auto;&quot;&gt;&lt;span style=&quot;white-space: pre; user-select: auto;&quot;&gt;	&lt;/span&gt;&lt;font style=&quot;font-size: 14px; user-select: auto;&quot;&gt;为了避免「缓存污染」造成的影响,在内存页被访问第二次的时候，才将页从 inactive list 升级到 active list 里。&lt;/font&gt;&lt;/div&gt;&lt;/font&gt;&lt;/div&gt;&lt;p style=&quot;user-select: auto;&quot;&gt;&lt;/p&gt;" style="rounded=0;whiteSpace=wrap;html=1;strokeColor=#36393d;fillColor=#cce5ff;align=left;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="640" y="2487" width="760" height="853" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
